Được truyền cảm hứng từ 1 bài research CVE của 1 anh trên mạng nào nó ;v, nên mình quyết định sẽ đi sâu và nghiên cứu 1 lô hổng CVE, thực ra mình lướt xem thì thấy cái 1 vuln mới công bố gần đây theo commit thì họ đã fix tầm 3 tuần trước rồi còn CVE thì mới công bố mấy hôm trước thôi
1.	Bief vulnerability:
-	CVE-2024-21505 là 1 lỗ hổng xuất hiện trên package web3-utils với các phiên bản 4.2.1 trở về trước đều có lỗ hổng  Prototype Pollution thông qua utility functions format và mergeDeep , điều đó dẫn tới việc đệ quy merger không an toàn. Hacker có thể thao túng protype của object và có khả năng dẫn đến thay đổi hành vi của tất cả các đối tượng kế thừa từ nguyên mẫu bị ảnh hưởng bằng cách chuyển đầu vào được chế tạo đặc biệt cho các chức năng này. (Đó là báo cáo tóm tắt thế ;v), giờ đến phần dig deeper.
2.	go deeper
-	So sánh phiên bản trước và sau khi vá:
 ![image](https://github.com/vanatka10/research/assets/126310360/76ac7dbd-7225-49c0-99ba-5280121a7da4)

Reference: https://github.com/web3/web3.js/commit/8ed041c6635d807b3da8960ad49e125e3d1b0e80
Trong đoạn commit này họ đã add space vào ngoặc chứa tên module(chắc bị ocd) và sửa shallow copy sang deep copy
Tại sao họ chỉ sửa vài dòng dường như không liên quan mà lại fix được nhỉ?  Một số câu hỏi hiện ra trong đầu mình shallow copy và deep copy khác nhau như nào nếu dùng trong json?

-	Trong mô tả vuln đã nói lỗ hổng xảy ra ở mergeDeep và nó ở đây
Ref:packages/web3-utils/src/objects.ts
```
/*
This file is part of web3.js.

web3.js is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

web3.js is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/

import { TypedArray } from 'web3-types';
import { isNullish } from 'web3-validator';

const isIterable = (item: unknown): item is Record<string, unknown> =>
	typeof item === 'object' &&
	!isNullish(item) &&
	!Array.isArray(item) &&
	!(item instanceof TypedArray);

// The following code is a derivative work of the code from the "LiskHQ/lisk-sdk" project,
// which is licensed under Apache version 2.
/**
 * Deep merge two objects.
 * @param destination - The destination object.
 * @param sources - An array of source objects.
 * @returns - The merged object.
 */
export const mergeDeep = (
	destination: Record<string, unknown>,
	...sources: Record<string, unknown>[]
): Record<string, unknown> => {
	if (!isIterable(destination)) {
		return destination;
	}
	const result = { ...destination }; // clone deep here
	for (const src of sources) {
		// const src = { ..._src };
		// eslint-disable-next-line no-restricted-syntax
		for (const key in src) {
			if (isIterable(src[key])) {
				if (!result[key]) {
					result[key] = {};
				}
				result[key] = mergeDeep(
					result[key] as Record<string, unknown>,
					src[key] as Record<string, unknown>,
				);
			} else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
				if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
					result[key] = (src[key] as unknown[]).slice(0);
				} else {
					result[key] = src[key];
				}
			}
		}
	}
	return result;
};
```
-	Đây là đoạn code đã được fix cũng không khác mấy lúc chưa fix nhỉ.
-	poc check lỗ hổng phiên bản:
ref:https://security.snyk.io/vuln/SNYK-JS-WEB3UTILS-6229337
![image](https://github.com/vanatka10/research/assets/126310360/5f54b25a-7509-4412-bab5-51e70ddacfb1)
 
-	Phiên bản 4.2.0:
  ![image](https://github.com/vanatka10/research/assets/126310360/aa212e2a-e2c9-4bcb-b229-449541d7ab83)

 
-	Phiên bản 4.2.1
  ![image](https://github.com/vanatka10/research/assets/126310360/4778af1a-7b9a-45da-bcc1-dd8afba43c93)

 
-	Mình tưởng code sẽ lấy hàm mergeDeep() ./src/objects.ts nên mình đã thử sửa nhưng khi chạy lại nó không thay đổi, sau 1 hồi mò thì ở web3-untils có 1 folder lib  nữa bên trong cũng chứa 1 file objects.js có vẻ các file đã được nạp vào thư viện để thực thi
-	Trong poc kiểm tra vuln có gọi 1 hàm format, khi mình thử thay đổi file objects.js về phiên bản mới , cả hai đều không bị pollution nữa. Có vẻ hàm format cũng gọi đến hàm mergerDeep() trong lúc nó được thực thi

-	Phân tích:
![image](https://github.com/vanatka10/research/assets/126310360/ece203d1-5845-45d9-a6f7-542ec072a007)

Hàm isIterable() để kiểm tra format của đối tượng được đưa vào.
![image](https://github.com/vanatka10/research/assets/126310360/5d9cc2d7-aa1a-447c-9e50-5532bdf239e5)


 
= Hàm mergeDeep() cho phép truyền các đối số destination và các đối số của sources copy tham số destination vào result và check điêu kiện. đến đoạn merge , sẽ thực hiện  merger các thuộc tính destination vào với nhau điều này có thể dẫn tới protype pollution 
 
![image](https://github.com/vanatka10/research/assets/126310360/a2f7a0fd-2a48-4c71-830b-28b60df17e80)

- Trong đoạn code này họ thực hiện shallow copy, mà khi dùng shallow copy ,khi result thay đổi thì sẽ dẫn tới destination cũng thay đổi theo từ có hacker có thể pollution tới các biến bên ngoài hàm
Lấy ví dụ:
![image](https://github.com/vanatka10/research/assets/126310360/775f3930-fb09-446e-a1f3-2b143ae616ef)

 
Cũng như việc ta thực hiện protype pollution trong hàm nó sẽ pollution đến các biến khác ngoài hàm
 
![image](https://github.com/vanatka10/research/assets/126310360/e1e31ac2-4f91-4342-854b-603565cd5d98)


Hết rồi, mình cũng muốn thử khai thác trên 1 webservice nhưng mình thấy lỗ hổng này chỉ khó ở việc tìm được vùng để exploit thôi, khi đã tìm ra chỗ để exploit rồi thì triển thôi có thể bypass auth, pollution attribute,rce,.. còn tùy vào trường hợp nữa. Chắc mấy ôg ra đề CTF sẽ thích vuln này:)).



